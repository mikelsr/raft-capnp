// Code generated by capnpc-go. DO NOT EDIT.

package api

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	fc "capnproto.org/go/capnp/v3/flowcontrol"
	schemas "capnproto.org/go/capnp/v3/schemas"
	server "capnproto.org/go/capnp/v3/server"
	context "context"
)

type Raft capnp.Client

// Raft_TypeID is the unique identifier for the type Raft.
const Raft_TypeID = 0xbfb4702210603dcb

func (c Raft) Join(ctx context.Context, params func(Raft_join_Params) error) (Raft_join_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xbfb4702210603dcb,
			MethodID:      0,
			InterfaceName: "raft.capnp:Raft",
			MethodName:    "join",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Raft_join_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Raft_join_Results_Future{Future: ans.Future()}, release

}

func (c Raft) Leave(ctx context.Context, params func(Raft_leave_Params) error) (Raft_leave_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xbfb4702210603dcb,
			MethodID:      1,
			InterfaceName: "raft.capnp:Raft",
			MethodName:    "leave",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Raft_leave_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Raft_leave_Results_Future{Future: ans.Future()}, release

}

func (c Raft) Send(ctx context.Context, params func(Raft_send_Params) error) (Raft_send_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xbfb4702210603dcb,
			MethodID:      2,
			InterfaceName: "raft.capnp:Raft",
			MethodName:    "send",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Raft_send_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Raft_send_Results_Future{Future: ans.Future()}, release

}

func (c Raft) Put(ctx context.Context, params func(Raft_put_Params) error) (Raft_put_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xbfb4702210603dcb,
			MethodID:      3,
			InterfaceName: "raft.capnp:Raft",
			MethodName:    "put",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 1}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Raft_put_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Raft_put_Results_Future{Future: ans.Future()}, release

}

func (c Raft) List(ctx context.Context, params func(Raft_list_Params) error) (Raft_list_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xbfb4702210603dcb,
			MethodID:      4,
			InterfaceName: "raft.capnp:Raft",
			MethodName:    "list",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Raft_list_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Raft_list_Results_Future{Future: ans.Future()}, release

}

func (c Raft) Members(ctx context.Context, params func(Raft_members_Params) error) (Raft_members_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xbfb4702210603dcb,
			MethodID:      5,
			InterfaceName: "raft.capnp:Raft",
			MethodName:    "members",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(Raft_members_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return Raft_members_Results_Future{Future: ans.Future()}, release

}

func (c Raft) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c Raft) String() string {
	return "Raft(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c Raft) AddRef() Raft {
	return Raft(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c Raft) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c Raft) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c Raft) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (Raft) DecodeFromPtr(p capnp.Ptr) Raft {
	return Raft(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c Raft) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c Raft) IsSame(other Raft) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c Raft) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c Raft) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A Raft_Server is a Raft with a local implementation.
type Raft_Server interface {
	Join(context.Context, Raft_join) error

	Leave(context.Context, Raft_leave) error

	Send(context.Context, Raft_send) error

	Put(context.Context, Raft_put) error

	List(context.Context, Raft_list) error

	Members(context.Context, Raft_members) error
}

// Raft_NewServer creates a new Server from an implementation of Raft_Server.
func Raft_NewServer(s Raft_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(Raft_Methods(nil, s), s, c)
}

// Raft_ServerToClient creates a new Client from an implementation of Raft_Server.
// The caller is responsible for calling Release on the returned Client.
func Raft_ServerToClient(s Raft_Server) Raft {
	return Raft(capnp.NewClient(Raft_NewServer(s)))
}

// Raft_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func Raft_Methods(methods []server.Method, s Raft_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 6)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xbfb4702210603dcb,
			MethodID:      0,
			InterfaceName: "raft.capnp:Raft",
			MethodName:    "join",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Join(ctx, Raft_join{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xbfb4702210603dcb,
			MethodID:      1,
			InterfaceName: "raft.capnp:Raft",
			MethodName:    "leave",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Leave(ctx, Raft_leave{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xbfb4702210603dcb,
			MethodID:      2,
			InterfaceName: "raft.capnp:Raft",
			MethodName:    "send",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Send(ctx, Raft_send{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xbfb4702210603dcb,
			MethodID:      3,
			InterfaceName: "raft.capnp:Raft",
			MethodName:    "put",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Put(ctx, Raft_put{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xbfb4702210603dcb,
			MethodID:      4,
			InterfaceName: "raft.capnp:Raft",
			MethodName:    "list",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.List(ctx, Raft_list{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xbfb4702210603dcb,
			MethodID:      5,
			InterfaceName: "raft.capnp:Raft",
			MethodName:    "members",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Members(ctx, Raft_members{call})
		},
	})

	return methods
}

// Raft_join holds the state for a server call to Raft.join.
// See server.Call for documentation.
type Raft_join struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Raft_join) Args() Raft_join_Params {
	return Raft_join_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Raft_join) AllocResults() (Raft_join_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Raft_join_Results(r), err
}

// Raft_leave holds the state for a server call to Raft.leave.
// See server.Call for documentation.
type Raft_leave struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Raft_leave) Args() Raft_leave_Params {
	return Raft_leave_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Raft_leave) AllocResults() (Raft_leave_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_leave_Results(r), err
}

// Raft_send holds the state for a server call to Raft.send.
// See server.Call for documentation.
type Raft_send struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Raft_send) Args() Raft_send_Params {
	return Raft_send_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Raft_send) AllocResults() (Raft_send_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_send_Results(r), err
}

// Raft_put holds the state for a server call to Raft.put.
// See server.Call for documentation.
type Raft_put struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Raft_put) Args() Raft_put_Params {
	return Raft_put_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Raft_put) AllocResults() (Raft_put_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_put_Results(r), err
}

// Raft_list holds the state for a server call to Raft.list.
// See server.Call for documentation.
type Raft_list struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Raft_list) Args() Raft_list_Params {
	return Raft_list_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Raft_list) AllocResults() (Raft_list_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_list_Results(r), err
}

// Raft_members holds the state for a server call to Raft.members.
// See server.Call for documentation.
type Raft_members struct {
	*server.Call
}

// Args returns the call's arguments.
func (c Raft_members) Args() Raft_members_Params {
	return Raft_members_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c Raft_members) AllocResults() (Raft_members_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_members_Results(r), err
}

// Raft_List is a list of Raft.
type Raft_List = capnp.CapList[Raft]

// NewRaft creates a new list of Raft.
func NewRaft_List(s *capnp.Segment, sz int32) (Raft_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[Raft](l), err
}

type Raft_join_Params capnp.Struct

// Raft_join_Params_TypeID is the unique identifier for the type Raft_join_Params.
const Raft_join_Params_TypeID = 0xc6f8efbe9e7d5983

func NewRaft_join_Params(s *capnp.Segment) (Raft_join_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_join_Params(st), err
}

func NewRootRaft_join_Params(s *capnp.Segment) (Raft_join_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_join_Params(st), err
}

func ReadRootRaft_join_Params(msg *capnp.Message) (Raft_join_Params, error) {
	root, err := msg.Root()
	return Raft_join_Params(root.Struct()), err
}

func (s Raft_join_Params) String() string {
	str, _ := text.Marshal(0xc6f8efbe9e7d5983, capnp.Struct(s))
	return str
}

func (s Raft_join_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Raft_join_Params) DecodeFromPtr(p capnp.Ptr) Raft_join_Params {
	return Raft_join_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Raft_join_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Raft_join_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Raft_join_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Raft_join_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Raft_join_Params) NodeInfo() NodeInfo {
	p, _ := capnp.Struct(s).Ptr(0)
	return NodeInfo(p.Interface().Client())
}

func (s Raft_join_Params) HasNodeInfo() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Raft_join_Params) SetNodeInfo(v NodeInfo) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// Raft_join_Params_List is a list of Raft_join_Params.
type Raft_join_Params_List = capnp.StructList[Raft_join_Params]

// NewRaft_join_Params creates a new list of Raft_join_Params.
func NewRaft_join_Params_List(s *capnp.Segment, sz int32) (Raft_join_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Raft_join_Params](l), err
}

// Raft_join_Params_Future is a wrapper for a Raft_join_Params promised by a client call.
type Raft_join_Params_Future struct{ *capnp.Future }

func (f Raft_join_Params_Future) Struct() (Raft_join_Params, error) {
	p, err := f.Future.Ptr()
	return Raft_join_Params(p.Struct()), err
}
func (p Raft_join_Params_Future) NodeInfo() NodeInfo {
	return NodeInfo(p.Future.Field(0, nil).Client())
}

type Raft_join_Results capnp.Struct

// Raft_join_Results_TypeID is the unique identifier for the type Raft_join_Results.
const Raft_join_Results_TypeID = 0xb009687519b3f38f

func NewRaft_join_Results(s *capnp.Segment) (Raft_join_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Raft_join_Results(st), err
}

func NewRootRaft_join_Results(s *capnp.Segment) (Raft_join_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Raft_join_Results(st), err
}

func ReadRootRaft_join_Results(msg *capnp.Message) (Raft_join_Results, error) {
	root, err := msg.Root()
	return Raft_join_Results(root.Struct()), err
}

func (s Raft_join_Results) String() string {
	str, _ := text.Marshal(0xb009687519b3f38f, capnp.Struct(s))
	return str
}

func (s Raft_join_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Raft_join_Results) DecodeFromPtr(p capnp.Ptr) Raft_join_Results {
	return Raft_join_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Raft_join_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Raft_join_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Raft_join_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Raft_join_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Raft_join_Results) Nodes() (NodeInfo_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return NodeInfo_List(p.List()), err
}

func (s Raft_join_Results) HasNodes() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Raft_join_Results) SetNodes(v NodeInfo_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewNodes sets the nodes field to a newly
// allocated NodeInfo_List, preferring placement in s's segment.
func (s Raft_join_Results) NewNodes(n int32) (NodeInfo_List, error) {
	l, err := NewNodeInfo_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return NodeInfo_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s Raft_join_Results) Error() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Raft_join_Results) HasError() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Raft_join_Results) ErrorBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Raft_join_Results) SetError(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

// Raft_join_Results_List is a list of Raft_join_Results.
type Raft_join_Results_List = capnp.StructList[Raft_join_Results]

// NewRaft_join_Results creates a new list of Raft_join_Results.
func NewRaft_join_Results_List(s *capnp.Segment, sz int32) (Raft_join_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Raft_join_Results](l), err
}

// Raft_join_Results_Future is a wrapper for a Raft_join_Results promised by a client call.
type Raft_join_Results_Future struct{ *capnp.Future }

func (f Raft_join_Results_Future) Struct() (Raft_join_Results, error) {
	p, err := f.Future.Ptr()
	return Raft_join_Results(p.Struct()), err
}

type Raft_leave_Params capnp.Struct

// Raft_leave_Params_TypeID is the unique identifier for the type Raft_leave_Params.
const Raft_leave_Params_TypeID = 0xf9ef9a25541688ef

func NewRaft_leave_Params(s *capnp.Segment) (Raft_leave_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_leave_Params(st), err
}

func NewRootRaft_leave_Params(s *capnp.Segment) (Raft_leave_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_leave_Params(st), err
}

func ReadRootRaft_leave_Params(msg *capnp.Message) (Raft_leave_Params, error) {
	root, err := msg.Root()
	return Raft_leave_Params(root.Struct()), err
}

func (s Raft_leave_Params) String() string {
	str, _ := text.Marshal(0xf9ef9a25541688ef, capnp.Struct(s))
	return str
}

func (s Raft_leave_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Raft_leave_Params) DecodeFromPtr(p capnp.Ptr) Raft_leave_Params {
	return Raft_leave_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Raft_leave_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Raft_leave_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Raft_leave_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Raft_leave_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Raft_leave_Params) NodeInfo() NodeInfo {
	p, _ := capnp.Struct(s).Ptr(0)
	return NodeInfo(p.Interface().Client())
}

func (s Raft_leave_Params) HasNodeInfo() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Raft_leave_Params) SetNodeInfo(v NodeInfo) error {
	if !v.IsValid() {
		return capnp.Struct(s).SetPtr(0, capnp.Ptr{})
	}
	seg := s.Segment()
	in := capnp.NewInterface(seg, seg.Message().CapTable().Add(capnp.Client(v)))
	return capnp.Struct(s).SetPtr(0, in.ToPtr())
}

// Raft_leave_Params_List is a list of Raft_leave_Params.
type Raft_leave_Params_List = capnp.StructList[Raft_leave_Params]

// NewRaft_leave_Params creates a new list of Raft_leave_Params.
func NewRaft_leave_Params_List(s *capnp.Segment, sz int32) (Raft_leave_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Raft_leave_Params](l), err
}

// Raft_leave_Params_Future is a wrapper for a Raft_leave_Params promised by a client call.
type Raft_leave_Params_Future struct{ *capnp.Future }

func (f Raft_leave_Params_Future) Struct() (Raft_leave_Params, error) {
	p, err := f.Future.Ptr()
	return Raft_leave_Params(p.Struct()), err
}
func (p Raft_leave_Params_Future) NodeInfo() NodeInfo {
	return NodeInfo(p.Future.Field(0, nil).Client())
}

type Raft_leave_Results capnp.Struct

// Raft_leave_Results_TypeID is the unique identifier for the type Raft_leave_Results.
const Raft_leave_Results_TypeID = 0xf139b86f408c2bb0

func NewRaft_leave_Results(s *capnp.Segment) (Raft_leave_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_leave_Results(st), err
}

func NewRootRaft_leave_Results(s *capnp.Segment) (Raft_leave_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_leave_Results(st), err
}

func ReadRootRaft_leave_Results(msg *capnp.Message) (Raft_leave_Results, error) {
	root, err := msg.Root()
	return Raft_leave_Results(root.Struct()), err
}

func (s Raft_leave_Results) String() string {
	str, _ := text.Marshal(0xf139b86f408c2bb0, capnp.Struct(s))
	return str
}

func (s Raft_leave_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Raft_leave_Results) DecodeFromPtr(p capnp.Ptr) Raft_leave_Results {
	return Raft_leave_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Raft_leave_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Raft_leave_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Raft_leave_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Raft_leave_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Raft_leave_Results) Error() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Raft_leave_Results) HasError() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Raft_leave_Results) ErrorBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Raft_leave_Results) SetError(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// Raft_leave_Results_List is a list of Raft_leave_Results.
type Raft_leave_Results_List = capnp.StructList[Raft_leave_Results]

// NewRaft_leave_Results creates a new list of Raft_leave_Results.
func NewRaft_leave_Results_List(s *capnp.Segment, sz int32) (Raft_leave_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Raft_leave_Results](l), err
}

// Raft_leave_Results_Future is a wrapper for a Raft_leave_Results promised by a client call.
type Raft_leave_Results_Future struct{ *capnp.Future }

func (f Raft_leave_Results_Future) Struct() (Raft_leave_Results, error) {
	p, err := f.Future.Ptr()
	return Raft_leave_Results(p.Struct()), err
}

type Raft_send_Params capnp.Struct

// Raft_send_Params_TypeID is the unique identifier for the type Raft_send_Params.
const Raft_send_Params_TypeID = 0xb1f8c610d8dbb7dd

func NewRaft_send_Params(s *capnp.Segment) (Raft_send_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_send_Params(st), err
}

func NewRootRaft_send_Params(s *capnp.Segment) (Raft_send_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_send_Params(st), err
}

func ReadRootRaft_send_Params(msg *capnp.Message) (Raft_send_Params, error) {
	root, err := msg.Root()
	return Raft_send_Params(root.Struct()), err
}

func (s Raft_send_Params) String() string {
	str, _ := text.Marshal(0xb1f8c610d8dbb7dd, capnp.Struct(s))
	return str
}

func (s Raft_send_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Raft_send_Params) DecodeFromPtr(p capnp.Ptr) Raft_send_Params {
	return Raft_send_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Raft_send_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Raft_send_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Raft_send_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Raft_send_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Raft_send_Params) Msg() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Raft_send_Params) HasMsg() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Raft_send_Params) SetMsg(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

// Raft_send_Params_List is a list of Raft_send_Params.
type Raft_send_Params_List = capnp.StructList[Raft_send_Params]

// NewRaft_send_Params creates a new list of Raft_send_Params.
func NewRaft_send_Params_List(s *capnp.Segment, sz int32) (Raft_send_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Raft_send_Params](l), err
}

// Raft_send_Params_Future is a wrapper for a Raft_send_Params promised by a client call.
type Raft_send_Params_Future struct{ *capnp.Future }

func (f Raft_send_Params_Future) Struct() (Raft_send_Params, error) {
	p, err := f.Future.Ptr()
	return Raft_send_Params(p.Struct()), err
}

type Raft_send_Results capnp.Struct

// Raft_send_Results_TypeID is the unique identifier for the type Raft_send_Results.
const Raft_send_Results_TypeID = 0xf26fa267f7ea2066

func NewRaft_send_Results(s *capnp.Segment) (Raft_send_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_send_Results(st), err
}

func NewRootRaft_send_Results(s *capnp.Segment) (Raft_send_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_send_Results(st), err
}

func ReadRootRaft_send_Results(msg *capnp.Message) (Raft_send_Results, error) {
	root, err := msg.Root()
	return Raft_send_Results(root.Struct()), err
}

func (s Raft_send_Results) String() string {
	str, _ := text.Marshal(0xf26fa267f7ea2066, capnp.Struct(s))
	return str
}

func (s Raft_send_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Raft_send_Results) DecodeFromPtr(p capnp.Ptr) Raft_send_Results {
	return Raft_send_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Raft_send_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Raft_send_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Raft_send_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Raft_send_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Raft_send_Results) Error() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Raft_send_Results) HasError() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Raft_send_Results) ErrorBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Raft_send_Results) SetError(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// Raft_send_Results_List is a list of Raft_send_Results.
type Raft_send_Results_List = capnp.StructList[Raft_send_Results]

// NewRaft_send_Results creates a new list of Raft_send_Results.
func NewRaft_send_Results_List(s *capnp.Segment, sz int32) (Raft_send_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Raft_send_Results](l), err
}

// Raft_send_Results_Future is a wrapper for a Raft_send_Results promised by a client call.
type Raft_send_Results_Future struct{ *capnp.Future }

func (f Raft_send_Results_Future) Struct() (Raft_send_Results, error) {
	p, err := f.Future.Ptr()
	return Raft_send_Results(p.Struct()), err
}

type Raft_put_Params capnp.Struct

// Raft_put_Params_TypeID is the unique identifier for the type Raft_put_Params.
const Raft_put_Params_TypeID = 0xd063789821634bd8

func NewRaft_put_Params(s *capnp.Segment) (Raft_put_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_put_Params(st), err
}

func NewRootRaft_put_Params(s *capnp.Segment) (Raft_put_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_put_Params(st), err
}

func ReadRootRaft_put_Params(msg *capnp.Message) (Raft_put_Params, error) {
	root, err := msg.Root()
	return Raft_put_Params(root.Struct()), err
}

func (s Raft_put_Params) String() string {
	str, _ := text.Marshal(0xd063789821634bd8, capnp.Struct(s))
	return str
}

func (s Raft_put_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Raft_put_Params) DecodeFromPtr(p capnp.Ptr) Raft_put_Params {
	return Raft_put_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Raft_put_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Raft_put_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Raft_put_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Raft_put_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Raft_put_Params) Item() (Item, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Item(p.Struct()), err
}

func (s Raft_put_Params) HasItem() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Raft_put_Params) SetItem(v Item) error {
	return capnp.Struct(s).SetPtr(0, capnp.Struct(v).ToPtr())
}

// NewItem sets the item field to a newly
// allocated Item struct, preferring placement in s's segment.
func (s Raft_put_Params) NewItem() (Item, error) {
	ss, err := NewItem(capnp.Struct(s).Segment())
	if err != nil {
		return Item{}, err
	}
	err = capnp.Struct(s).SetPtr(0, capnp.Struct(ss).ToPtr())
	return ss, err
}

// Raft_put_Params_List is a list of Raft_put_Params.
type Raft_put_Params_List = capnp.StructList[Raft_put_Params]

// NewRaft_put_Params creates a new list of Raft_put_Params.
func NewRaft_put_Params_List(s *capnp.Segment, sz int32) (Raft_put_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Raft_put_Params](l), err
}

// Raft_put_Params_Future is a wrapper for a Raft_put_Params promised by a client call.
type Raft_put_Params_Future struct{ *capnp.Future }

func (f Raft_put_Params_Future) Struct() (Raft_put_Params, error) {
	p, err := f.Future.Ptr()
	return Raft_put_Params(p.Struct()), err
}
func (p Raft_put_Params_Future) Item() Item_Future {
	return Item_Future{Future: p.Future.Field(0, nil)}
}

type Raft_put_Results capnp.Struct

// Raft_put_Results_TypeID is the unique identifier for the type Raft_put_Results.
const Raft_put_Results_TypeID = 0x9c4beb6b068077a3

func NewRaft_put_Results(s *capnp.Segment) (Raft_put_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_put_Results(st), err
}

func NewRootRaft_put_Results(s *capnp.Segment) (Raft_put_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_put_Results(st), err
}

func ReadRootRaft_put_Results(msg *capnp.Message) (Raft_put_Results, error) {
	root, err := msg.Root()
	return Raft_put_Results(root.Struct()), err
}

func (s Raft_put_Results) String() string {
	str, _ := text.Marshal(0x9c4beb6b068077a3, capnp.Struct(s))
	return str
}

func (s Raft_put_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Raft_put_Results) DecodeFromPtr(p capnp.Ptr) Raft_put_Results {
	return Raft_put_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Raft_put_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Raft_put_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Raft_put_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Raft_put_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Raft_put_Results) Error() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Raft_put_Results) HasError() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Raft_put_Results) ErrorBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Raft_put_Results) SetError(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// Raft_put_Results_List is a list of Raft_put_Results.
type Raft_put_Results_List = capnp.StructList[Raft_put_Results]

// NewRaft_put_Results creates a new list of Raft_put_Results.
func NewRaft_put_Results_List(s *capnp.Segment, sz int32) (Raft_put_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Raft_put_Results](l), err
}

// Raft_put_Results_Future is a wrapper for a Raft_put_Results promised by a client call.
type Raft_put_Results_Future struct{ *capnp.Future }

func (f Raft_put_Results_Future) Struct() (Raft_put_Results, error) {
	p, err := f.Future.Ptr()
	return Raft_put_Results(p.Struct()), err
}

type Raft_list_Params capnp.Struct

// Raft_list_Params_TypeID is the unique identifier for the type Raft_list_Params.
const Raft_list_Params_TypeID = 0xf16297be3b2d1ee4

func NewRaft_list_Params(s *capnp.Segment) (Raft_list_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Raft_list_Params(st), err
}

func NewRootRaft_list_Params(s *capnp.Segment) (Raft_list_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Raft_list_Params(st), err
}

func ReadRootRaft_list_Params(msg *capnp.Message) (Raft_list_Params, error) {
	root, err := msg.Root()
	return Raft_list_Params(root.Struct()), err
}

func (s Raft_list_Params) String() string {
	str, _ := text.Marshal(0xf16297be3b2d1ee4, capnp.Struct(s))
	return str
}

func (s Raft_list_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Raft_list_Params) DecodeFromPtr(p capnp.Ptr) Raft_list_Params {
	return Raft_list_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Raft_list_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Raft_list_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Raft_list_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Raft_list_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Raft_list_Params_List is a list of Raft_list_Params.
type Raft_list_Params_List = capnp.StructList[Raft_list_Params]

// NewRaft_list_Params creates a new list of Raft_list_Params.
func NewRaft_list_Params_List(s *capnp.Segment, sz int32) (Raft_list_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Raft_list_Params](l), err
}

// Raft_list_Params_Future is a wrapper for a Raft_list_Params promised by a client call.
type Raft_list_Params_Future struct{ *capnp.Future }

func (f Raft_list_Params_Future) Struct() (Raft_list_Params, error) {
	p, err := f.Future.Ptr()
	return Raft_list_Params(p.Struct()), err
}

type Raft_list_Results capnp.Struct

// Raft_list_Results_TypeID is the unique identifier for the type Raft_list_Results.
const Raft_list_Results_TypeID = 0xeb05cc390961a49a

func NewRaft_list_Results(s *capnp.Segment) (Raft_list_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_list_Results(st), err
}

func NewRootRaft_list_Results(s *capnp.Segment) (Raft_list_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_list_Results(st), err
}

func ReadRootRaft_list_Results(msg *capnp.Message) (Raft_list_Results, error) {
	root, err := msg.Root()
	return Raft_list_Results(root.Struct()), err
}

func (s Raft_list_Results) String() string {
	str, _ := text.Marshal(0xeb05cc390961a49a, capnp.Struct(s))
	return str
}

func (s Raft_list_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Raft_list_Results) DecodeFromPtr(p capnp.Ptr) Raft_list_Results {
	return Raft_list_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Raft_list_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Raft_list_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Raft_list_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Raft_list_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Raft_list_Results) Objects() (Item_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Item_List(p.List()), err
}

func (s Raft_list_Results) HasObjects() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Raft_list_Results) SetObjects(v Item_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewObjects sets the objects field to a newly
// allocated Item_List, preferring placement in s's segment.
func (s Raft_list_Results) NewObjects(n int32) (Item_List, error) {
	l, err := NewItem_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Item_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// Raft_list_Results_List is a list of Raft_list_Results.
type Raft_list_Results_List = capnp.StructList[Raft_list_Results]

// NewRaft_list_Results creates a new list of Raft_list_Results.
func NewRaft_list_Results_List(s *capnp.Segment, sz int32) (Raft_list_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Raft_list_Results](l), err
}

// Raft_list_Results_Future is a wrapper for a Raft_list_Results promised by a client call.
type Raft_list_Results_Future struct{ *capnp.Future }

func (f Raft_list_Results_Future) Struct() (Raft_list_Results, error) {
	p, err := f.Future.Ptr()
	return Raft_list_Results(p.Struct()), err
}

type Raft_members_Params capnp.Struct

// Raft_members_Params_TypeID is the unique identifier for the type Raft_members_Params.
const Raft_members_Params_TypeID = 0xf561891b2176587a

func NewRaft_members_Params(s *capnp.Segment) (Raft_members_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Raft_members_Params(st), err
}

func NewRootRaft_members_Params(s *capnp.Segment) (Raft_members_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return Raft_members_Params(st), err
}

func ReadRootRaft_members_Params(msg *capnp.Message) (Raft_members_Params, error) {
	root, err := msg.Root()
	return Raft_members_Params(root.Struct()), err
}

func (s Raft_members_Params) String() string {
	str, _ := text.Marshal(0xf561891b2176587a, capnp.Struct(s))
	return str
}

func (s Raft_members_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Raft_members_Params) DecodeFromPtr(p capnp.Ptr) Raft_members_Params {
	return Raft_members_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Raft_members_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Raft_members_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Raft_members_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Raft_members_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// Raft_members_Params_List is a list of Raft_members_Params.
type Raft_members_Params_List = capnp.StructList[Raft_members_Params]

// NewRaft_members_Params creates a new list of Raft_members_Params.
func NewRaft_members_Params_List(s *capnp.Segment, sz int32) (Raft_members_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[Raft_members_Params](l), err
}

// Raft_members_Params_Future is a wrapper for a Raft_members_Params promised by a client call.
type Raft_members_Params_Future struct{ *capnp.Future }

func (f Raft_members_Params_Future) Struct() (Raft_members_Params, error) {
	p, err := f.Future.Ptr()
	return Raft_members_Params(p.Struct()), err
}

type Raft_members_Results capnp.Struct

// Raft_members_Results_TypeID is the unique identifier for the type Raft_members_Results.
const Raft_members_Results_TypeID = 0xbd2f697b2c16b9a9

func NewRaft_members_Results(s *capnp.Segment) (Raft_members_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_members_Results(st), err
}

func NewRootRaft_members_Results(s *capnp.Segment) (Raft_members_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return Raft_members_Results(st), err
}

func ReadRootRaft_members_Results(msg *capnp.Message) (Raft_members_Results, error) {
	root, err := msg.Root()
	return Raft_members_Results(root.Struct()), err
}

func (s Raft_members_Results) String() string {
	str, _ := text.Marshal(0xbd2f697b2c16b9a9, capnp.Struct(s))
	return str
}

func (s Raft_members_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Raft_members_Results) DecodeFromPtr(p capnp.Ptr) Raft_members_Results {
	return Raft_members_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Raft_members_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Raft_members_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Raft_members_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Raft_members_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Raft_members_Results) Members() (NodeInfo_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return NodeInfo_List(p.List()), err
}

func (s Raft_members_Results) HasMembers() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Raft_members_Results) SetMembers(v NodeInfo_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewMembers sets the members field to a newly
// allocated NodeInfo_List, preferring placement in s's segment.
func (s Raft_members_Results) NewMembers(n int32) (NodeInfo_List, error) {
	l, err := NewNodeInfo_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return NodeInfo_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// Raft_members_Results_List is a list of Raft_members_Results.
type Raft_members_Results_List = capnp.StructList[Raft_members_Results]

// NewRaft_members_Results creates a new list of Raft_members_Results.
func NewRaft_members_Results_List(s *capnp.Segment, sz int32) (Raft_members_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[Raft_members_Results](l), err
}

// Raft_members_Results_Future is a wrapper for a Raft_members_Results promised by a client call.
type Raft_members_Results_Future struct{ *capnp.Future }

func (f Raft_members_Results_Future) Struct() (Raft_members_Results, error) {
	p, err := f.Future.Ptr()
	return Raft_members_Results(p.Struct()), err
}

type Item capnp.Struct

// Item_TypeID is the unique identifier for the type Item.
const Item_TypeID = 0xae462da6618b7135

func NewItem(s *capnp.Segment) (Item, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Item(st), err
}

func NewRootItem(s *capnp.Segment) (Item, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return Item(st), err
}

func ReadRootItem(msg *capnp.Message) (Item, error) {
	root, err := msg.Root()
	return Item(root.Struct()), err
}

func (s Item) String() string {
	str, _ := text.Marshal(0xae462da6618b7135, capnp.Struct(s))
	return str
}

func (s Item) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Item) DecodeFromPtr(p capnp.Ptr) Item {
	return Item(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Item) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Item) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Item) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Item) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Item) Key() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return []byte(p.Data()), err
}

func (s Item) HasKey() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Item) SetKey(v []byte) error {
	return capnp.Struct(s).SetData(0, v)
}

func (s Item) Value() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return []byte(p.Data()), err
}

func (s Item) HasValue() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Item) SetValue(v []byte) error {
	return capnp.Struct(s).SetData(1, v)
}

// Item_List is a list of Item.
type Item_List = capnp.StructList[Item]

// NewItem creates a new list of Item.
func NewItem_List(s *capnp.Segment, sz int32) (Item_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[Item](l), err
}

// Item_Future is a wrapper for a Item promised by a client call.
type Item_Future struct{ *capnp.Future }

func (f Item_Future) Struct() (Item, error) {
	p, err := f.Future.Ptr()
	return Item(p.Struct()), err
}

type NodeInfo capnp.Client

// NodeInfo_TypeID is the unique identifier for the type NodeInfo.
const NodeInfo_TypeID = 0xf3dbf85049fe61f0

func (c NodeInfo) Id(ctx context.Context, params func(NodeInfo_id_Params) error) (NodeInfo_id_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf3dbf85049fe61f0,
			MethodID:      0,
			InterfaceName: "raft.capnp:NodeInfo",
			MethodName:    "id",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(NodeInfo_id_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return NodeInfo_id_Results_Future{Future: ans.Future()}, release

}

func (c NodeInfo) Channel(ctx context.Context, params func(NodeInfo_channel_Params) error) (NodeInfo_channel_Results_Future, capnp.ReleaseFunc) {

	s := capnp.Send{
		Method: capnp.Method{
			InterfaceID:   0xf3dbf85049fe61f0,
			MethodID:      1,
			InterfaceName: "raft.capnp:NodeInfo",
			MethodName:    "channel",
		},
	}
	if params != nil {
		s.ArgsSize = capnp.ObjectSize{DataSize: 0, PointerCount: 0}
		s.PlaceArgs = func(s capnp.Struct) error { return params(NodeInfo_channel_Params(s)) }
	}

	ans, release := capnp.Client(c).SendCall(ctx, s)
	return NodeInfo_channel_Results_Future{Future: ans.Future()}, release

}

func (c NodeInfo) WaitStreaming() error {
	return capnp.Client(c).WaitStreaming()
}

// String returns a string that identifies this capability for debugging
// purposes.  Its format should not be depended on: in particular, it
// should not be used to compare clients.  Use IsSame to compare clients
// for equality.
func (c NodeInfo) String() string {
	return "NodeInfo(" + capnp.Client(c).String() + ")"
}

// AddRef creates a new Client that refers to the same capability as c.
// If c is nil or has resolved to null, then AddRef returns nil.
func (c NodeInfo) AddRef() NodeInfo {
	return NodeInfo(capnp.Client(c).AddRef())
}

// Release releases a capability reference.  If this is the last
// reference to the capability, then the underlying resources associated
// with the capability will be released.
//
// Release will panic if c has already been released, but not if c is
// nil or resolved to null.
func (c NodeInfo) Release() {
	capnp.Client(c).Release()
}

// Resolve blocks until the capability is fully resolved or the Context
// expires.
func (c NodeInfo) Resolve(ctx context.Context) error {
	return capnp.Client(c).Resolve(ctx)
}

func (c NodeInfo) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Client(c).EncodeAsPtr(seg)
}

func (NodeInfo) DecodeFromPtr(p capnp.Ptr) NodeInfo {
	return NodeInfo(capnp.Client{}.DecodeFromPtr(p))
}

// IsValid reports whether c is a valid reference to a capability.
// A reference is invalid if it is nil, has resolved to null, or has
// been released.
func (c NodeInfo) IsValid() bool {
	return capnp.Client(c).IsValid()
}

// IsSame reports whether c and other refer to a capability created by the
// same call to NewClient.  This can return false negatives if c or other
// are not fully resolved: use Resolve if this is an issue.  If either
// c or other are released, then IsSame panics.
func (c NodeInfo) IsSame(other NodeInfo) bool {
	return capnp.Client(c).IsSame(capnp.Client(other))
}

// Update the flowcontrol.FlowLimiter used to manage flow control for
// this client. This affects all future calls, but not calls already
// waiting to send. Passing nil sets the value to flowcontrol.NopLimiter,
// which is also the default.
func (c NodeInfo) SetFlowLimiter(lim fc.FlowLimiter) {
	capnp.Client(c).SetFlowLimiter(lim)
}

// Get the current flowcontrol.FlowLimiter used to manage flow control
// for this client.
func (c NodeInfo) GetFlowLimiter() fc.FlowLimiter {
	return capnp.Client(c).GetFlowLimiter()
}

// A NodeInfo_Server is a NodeInfo with a local implementation.
type NodeInfo_Server interface {
	Id(context.Context, NodeInfo_id) error

	Channel(context.Context, NodeInfo_channel) error
}

// NodeInfo_NewServer creates a new Server from an implementation of NodeInfo_Server.
func NodeInfo_NewServer(s NodeInfo_Server) *server.Server {
	c, _ := s.(server.Shutdowner)
	return server.New(NodeInfo_Methods(nil, s), s, c)
}

// NodeInfo_ServerToClient creates a new Client from an implementation of NodeInfo_Server.
// The caller is responsible for calling Release on the returned Client.
func NodeInfo_ServerToClient(s NodeInfo_Server) NodeInfo {
	return NodeInfo(capnp.NewClient(NodeInfo_NewServer(s)))
}

// NodeInfo_Methods appends Methods to a slice that invoke the methods on s.
// This can be used to create a more complicated Server.
func NodeInfo_Methods(methods []server.Method, s NodeInfo_Server) []server.Method {
	if cap(methods) == 0 {
		methods = make([]server.Method, 0, 2)
	}

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf3dbf85049fe61f0,
			MethodID:      0,
			InterfaceName: "raft.capnp:NodeInfo",
			MethodName:    "id",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Id(ctx, NodeInfo_id{call})
		},
	})

	methods = append(methods, server.Method{
		Method: capnp.Method{
			InterfaceID:   0xf3dbf85049fe61f0,
			MethodID:      1,
			InterfaceName: "raft.capnp:NodeInfo",
			MethodName:    "channel",
		},
		Impl: func(ctx context.Context, call *server.Call) error {
			return s.Channel(ctx, NodeInfo_channel{call})
		},
	})

	return methods
}

// NodeInfo_id holds the state for a server call to NodeInfo.id.
// See server.Call for documentation.
type NodeInfo_id struct {
	*server.Call
}

// Args returns the call's arguments.
func (c NodeInfo_id) Args() NodeInfo_id_Params {
	return NodeInfo_id_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c NodeInfo_id) AllocResults() (NodeInfo_id_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return NodeInfo_id_Results(r), err
}

// NodeInfo_channel holds the state for a server call to NodeInfo.channel.
// See server.Call for documentation.
type NodeInfo_channel struct {
	*server.Call
}

// Args returns the call's arguments.
func (c NodeInfo_channel) Args() NodeInfo_channel_Params {
	return NodeInfo_channel_Params(c.Call.Args())
}

// AllocResults allocates the results struct.
func (c NodeInfo_channel) AllocResults() (NodeInfo_channel_Results, error) {
	r, err := c.Call.AllocResults(capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return NodeInfo_channel_Results(r), err
}

// NodeInfo_List is a list of NodeInfo.
type NodeInfo_List = capnp.CapList[NodeInfo]

// NewNodeInfo creates a new list of NodeInfo.
func NewNodeInfo_List(s *capnp.Segment, sz int32) (NodeInfo_List, error) {
	l, err := capnp.NewPointerList(s, sz)
	return capnp.CapList[NodeInfo](l), err
}

type NodeInfo_id_Params capnp.Struct

// NodeInfo_id_Params_TypeID is the unique identifier for the type NodeInfo_id_Params.
const NodeInfo_id_Params_TypeID = 0x870cd3c7477f97c3

func NewNodeInfo_id_Params(s *capnp.Segment) (NodeInfo_id_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return NodeInfo_id_Params(st), err
}

func NewRootNodeInfo_id_Params(s *capnp.Segment) (NodeInfo_id_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return NodeInfo_id_Params(st), err
}

func ReadRootNodeInfo_id_Params(msg *capnp.Message) (NodeInfo_id_Params, error) {
	root, err := msg.Root()
	return NodeInfo_id_Params(root.Struct()), err
}

func (s NodeInfo_id_Params) String() string {
	str, _ := text.Marshal(0x870cd3c7477f97c3, capnp.Struct(s))
	return str
}

func (s NodeInfo_id_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (NodeInfo_id_Params) DecodeFromPtr(p capnp.Ptr) NodeInfo_id_Params {
	return NodeInfo_id_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s NodeInfo_id_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s NodeInfo_id_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s NodeInfo_id_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s NodeInfo_id_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// NodeInfo_id_Params_List is a list of NodeInfo_id_Params.
type NodeInfo_id_Params_List = capnp.StructList[NodeInfo_id_Params]

// NewNodeInfo_id_Params creates a new list of NodeInfo_id_Params.
func NewNodeInfo_id_Params_List(s *capnp.Segment, sz int32) (NodeInfo_id_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[NodeInfo_id_Params](l), err
}

// NodeInfo_id_Params_Future is a wrapper for a NodeInfo_id_Params promised by a client call.
type NodeInfo_id_Params_Future struct{ *capnp.Future }

func (f NodeInfo_id_Params_Future) Struct() (NodeInfo_id_Params, error) {
	p, err := f.Future.Ptr()
	return NodeInfo_id_Params(p.Struct()), err
}

type NodeInfo_id_Results capnp.Struct

// NodeInfo_id_Results_TypeID is the unique identifier for the type NodeInfo_id_Results.
const NodeInfo_id_Results_TypeID = 0xc80a93339b37cb72

func NewNodeInfo_id_Results(s *capnp.Segment) (NodeInfo_id_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return NodeInfo_id_Results(st), err
}

func NewRootNodeInfo_id_Results(s *capnp.Segment) (NodeInfo_id_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0})
	return NodeInfo_id_Results(st), err
}

func ReadRootNodeInfo_id_Results(msg *capnp.Message) (NodeInfo_id_Results, error) {
	root, err := msg.Root()
	return NodeInfo_id_Results(root.Struct()), err
}

func (s NodeInfo_id_Results) String() string {
	str, _ := text.Marshal(0xc80a93339b37cb72, capnp.Struct(s))
	return str
}

func (s NodeInfo_id_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (NodeInfo_id_Results) DecodeFromPtr(p capnp.Ptr) NodeInfo_id_Results {
	return NodeInfo_id_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s NodeInfo_id_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s NodeInfo_id_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s NodeInfo_id_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s NodeInfo_id_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s NodeInfo_id_Results) Id() uint64 {
	return capnp.Struct(s).Uint64(0)
}

func (s NodeInfo_id_Results) SetId(v uint64) {
	capnp.Struct(s).SetUint64(0, v)
}

// NodeInfo_id_Results_List is a list of NodeInfo_id_Results.
type NodeInfo_id_Results_List = capnp.StructList[NodeInfo_id_Results]

// NewNodeInfo_id_Results creates a new list of NodeInfo_id_Results.
func NewNodeInfo_id_Results_List(s *capnp.Segment, sz int32) (NodeInfo_id_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 0}, sz)
	return capnp.StructList[NodeInfo_id_Results](l), err
}

// NodeInfo_id_Results_Future is a wrapper for a NodeInfo_id_Results promised by a client call.
type NodeInfo_id_Results_Future struct{ *capnp.Future }

func (f NodeInfo_id_Results_Future) Struct() (NodeInfo_id_Results, error) {
	p, err := f.Future.Ptr()
	return NodeInfo_id_Results(p.Struct()), err
}

type NodeInfo_channel_Params capnp.Struct

// NodeInfo_channel_Params_TypeID is the unique identifier for the type NodeInfo_channel_Params.
const NodeInfo_channel_Params_TypeID = 0xdb920c957d5a078c

func NewNodeInfo_channel_Params(s *capnp.Segment) (NodeInfo_channel_Params, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return NodeInfo_channel_Params(st), err
}

func NewRootNodeInfo_channel_Params(s *capnp.Segment) (NodeInfo_channel_Params, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0})
	return NodeInfo_channel_Params(st), err
}

func ReadRootNodeInfo_channel_Params(msg *capnp.Message) (NodeInfo_channel_Params, error) {
	root, err := msg.Root()
	return NodeInfo_channel_Params(root.Struct()), err
}

func (s NodeInfo_channel_Params) String() string {
	str, _ := text.Marshal(0xdb920c957d5a078c, capnp.Struct(s))
	return str
}

func (s NodeInfo_channel_Params) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (NodeInfo_channel_Params) DecodeFromPtr(p capnp.Ptr) NodeInfo_channel_Params {
	return NodeInfo_channel_Params(capnp.Struct{}.DecodeFromPtr(p))
}

func (s NodeInfo_channel_Params) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s NodeInfo_channel_Params) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s NodeInfo_channel_Params) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s NodeInfo_channel_Params) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}

// NodeInfo_channel_Params_List is a list of NodeInfo_channel_Params.
type NodeInfo_channel_Params_List = capnp.StructList[NodeInfo_channel_Params]

// NewNodeInfo_channel_Params creates a new list of NodeInfo_channel_Params.
func NewNodeInfo_channel_Params_List(s *capnp.Segment, sz int32) (NodeInfo_channel_Params_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 0}, sz)
	return capnp.StructList[NodeInfo_channel_Params](l), err
}

// NodeInfo_channel_Params_Future is a wrapper for a NodeInfo_channel_Params promised by a client call.
type NodeInfo_channel_Params_Future struct{ *capnp.Future }

func (f NodeInfo_channel_Params_Future) Struct() (NodeInfo_channel_Params, error) {
	p, err := f.Future.Ptr()
	return NodeInfo_channel_Params(p.Struct()), err
}

type NodeInfo_channel_Results capnp.Struct

// NodeInfo_channel_Results_TypeID is the unique identifier for the type NodeInfo_channel_Results.
const NodeInfo_channel_Results_TypeID = 0xf1fdeb63c6e87042

func NewNodeInfo_channel_Results(s *capnp.Segment) (NodeInfo_channel_Results, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return NodeInfo_channel_Results(st), err
}

func NewRootNodeInfo_channel_Results(s *capnp.Segment) (NodeInfo_channel_Results, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return NodeInfo_channel_Results(st), err
}

func ReadRootNodeInfo_channel_Results(msg *capnp.Message) (NodeInfo_channel_Results, error) {
	root, err := msg.Root()
	return NodeInfo_channel_Results(root.Struct()), err
}

func (s NodeInfo_channel_Results) String() string {
	str, _ := text.Marshal(0xf1fdeb63c6e87042, capnp.Struct(s))
	return str
}

func (s NodeInfo_channel_Results) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (NodeInfo_channel_Results) DecodeFromPtr(p capnp.Ptr) NodeInfo_channel_Results {
	return NodeInfo_channel_Results(capnp.Struct{}.DecodeFromPtr(p))
}

func (s NodeInfo_channel_Results) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s NodeInfo_channel_Results) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s NodeInfo_channel_Results) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s NodeInfo_channel_Results) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s NodeInfo_channel_Results) Chan() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s NodeInfo_channel_Results) HasChan() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s NodeInfo_channel_Results) ChanBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s NodeInfo_channel_Results) SetChan(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

// NodeInfo_channel_Results_List is a list of NodeInfo_channel_Results.
type NodeInfo_channel_Results_List = capnp.StructList[NodeInfo_channel_Results]

// NewNodeInfo_channel_Results creates a new list of NodeInfo_channel_Results.
func NewNodeInfo_channel_Results_List(s *capnp.Segment, sz int32) (NodeInfo_channel_Results_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[NodeInfo_channel_Results](l), err
}

// NodeInfo_channel_Results_Future is a wrapper for a NodeInfo_channel_Results promised by a client call.
type NodeInfo_channel_Results_Future struct{ *capnp.Future }

func (f NodeInfo_channel_Results_Future) Struct() (NodeInfo_channel_Results, error) {
	p, err := f.Future.Ptr()
	return NodeInfo_channel_Results(p.Struct()), err
}

const schema_8dcfa60b52844164 = "x\xda\x9cU]h\x1cU\x14>\xe7\xde\xf9\xe9\x9al" +
	"w/\x13K\x1b\xc1\xb5\xcb\x16\xb4\xba\xb5I\x14M%" +
	"d\x1a\xac\x12\x0b\xb2\xb3\xf8\xa0\xa2\xe0dw\xd2n\xbb" +
	";\xbb\x9d\x9dM\xfd!D\xab\x10\xc5\x16Q\x91j\xfd" +
	"\xc3\xaa\x05_\xa4AE}\xb0R\xa4Q\xa9\xa0 B" +
	"5\xf4\xc1b@\x9b\x87\xd8\x141-\xd4\x91;;3" +
	";\x9b\xdd\xb5\xd2\xb7;s~\xbes\xbf\xf3\x9ds7" +
	"\xbfMT\xa1/\xba(\x03\xd1\x1e\x12%\xe7\xab\x83S" +
	"w\x7f\xfdc\xf74\xb0\x1e\x04\x10d\x00\xe54]\x02" +
	"\xc1yw\xef\x93\xd2\xee\x85\xedo\x00\x8b#\x80\x88\xdc" +
	"r\x9c\x9e\x01TN\xd0a@\xe7\xd6=\xcf\xebG\xd2" +
	"w}\x08\xac\x0b\x9d\xfc\xd6g\xb2]G\xbe?\x00\"" +
	"\xe1~\xf3t\x9f\xf2\x07\xad\x9f\xf6\x02:/\x9c\xffh" +
	"]mg\xe4\xa8\x97\xcb\xf5\xd9*\x9c\x05T\xb6\x09\xdc" +
	"~\xfa\xd3\xb9S\xf1\xd9\xe5\x990\xd6\x8c\xc0\xb1>\x11" +
	"8\xd6\x07\x9f\xaf\xb9\xe9\x89\xc2\xcd_\x84\xec\x03?\x09" +
	"\x04\x01\x95\x9f]\x87\x93C\x8f\xc4\x93\x95\x8f\xbf\x04\xd6" +
	"E\x1b\xc5\x00*\x11q\x9f\x12\x15\xb9\x7fD\x9cF\xe5" +
	"\x02?:O?0\xf9\xd6\xb1\xc5\xe5\xd90\xdc\xaf\"" +
	"\x87\x9b\x17y6\xeb\xe4m\xaf\x0f\xbc|\xd57\xa0\xf5" +
	"\xa0OJD\xba\x08\xa8D%n?\xb5=\xb7\xfe\xd5" +
	"Gs?\x84\xe3\xd3\xd2/\x80J\x9fk\xdf/?8" +
	"\xf9J\xf7Ks\x0dN\x074\xa9\x17Ap\x0e\xbd\xa7" +
	"G\x06\xbf\x13\x17\xc2\x91\x83\x12'b\xc8\x8d<z\xe3" +
	"~\xb5\xfc\xd9\xe0\xb9\xb0\xbd$-\x01*{\\\xfbo" +
	"\xd7\xa6\xef8vp\xcc\xb3\xbb\x85\xbd(\x9d\x01\xc1\x19" +
	"\xa9\xfc>\x9b[\xb8t\xae\x0eYg\xa8&%9C" +
	"\x93n\xe4\xf8ug\xff\xdeq\xb8\xbc\x14\xce\xfc\xa6\x8b" +
	"\xfc\x8ek\xffS\xffg4\xb3<w\xbe\x85\xc1\xe3\xd2" +
	"a\xe5[\x89\xbb\x9f\x90\xa6\x95\xabeN\xe0\xe3\xf7O" +
	"\xac\xbf\xe69\xfd\xafP\x19\x97\xa4\x8b 8\x8b\xcf\xae" +
	"\xb9o\xc3\xa1\xc5\x0bM\xcc\xba(\xf3\xd20\xa4\x1dK" +
	"\x1f\xb77\xe5\xf4\x0a1+[\xee-\xe7\x8dQs\xbc" +
	"\xbc\xa9\x90Oe\x12\xba\xa5\x97\xaaM\xf6,?Wj" +
	"v*kTkr\xd1\xaej\x02\x15\x00\x04\x04`\xd1" +
	"~\x00m\x15E\xad\x87`\xc2\xb0\xac\xb2\x85\xdd@\xb0" +
	"\x9b7\xcfK\x81fe\xcb\xa8m\x94 \x83\xa8\xad\x0a" +
	"\"oH\x02h)\x8a\xdaf\x82\x0c\xd1m0K\xf3" +
	"t\xd7S\xd4n!(\xef6\x1e\xc3(\x10\x8c\x02&" +
	"&\xf4b\xcd\xf0\xbfZ\xab\xdbU.\x98\xbc\xbcX\x8d" +
	"\x97\x17\x02\xe9\xf7@\xd4\x10\xc8\x10\xffy;E\xedN" +
	"\x82\x09\xb3\x9c7\xaa\xb8\x1a0C\x11Y\x83}@\xfe" +
	"\xb3\xc3\x95\x02\xdc\xaaa\xe6S\x19\xdd\x92\xf5R\x13+" +
	"\xc9\x06+r\xa9\xba\xa3\xa5p\xea'(\x19\xa51\xc3" +
	"\xaa\xba\xd4\x16\xed*\x84\x93\x8cxIR\x04\xa7<\xbf" +
	"\x8e\x856\xb1\xcd3\xbbl\xaf\xa5bh\xca\xd0\x9f~" +
	"6\xb3\x11\x08{_F\x0ct\x82\xbe\xe0\xd9k\xfd@" +
	"\xd8\x01\x19I\xb0\x0c\xd0\x97,{\x8a\xc7\xd5d\xa4\xc1" +
	"\xe4\xa1\xbf\x9dX!\x09\x84=,\xa3\x10\xcc\x06\xfaC" +
	"\xc64\x1e\xb7MF1\x10,\xfa\x9b\x84\x0d\x8e\x00a" +
	"i9\xc6[\xa8b\xa2h\xe8\x13\x86\x8a1\xce\xac\x8a" +
	"r\xa5f\xab\x18+\x16\xaa\xb6\x1a\x90\xa0b\x06;i" +
	"\xa0M/\xee\x01\xd0\xba)jk\x09:\xa6'u\x00" +
	"X\xc1![\xd1\xde\xf0Pd\x87\xeb\xdd\x09g\xedm" +
	"t\x98\x16\xf2\x18\x01\x82\x91v\x0a\xe1s\x93\xd1-\x9d" +
	"6\x17\xb5\xb1\x11\x1e+\xd8F\x09\xe3\x8d=\x0e\x88\xf1" +
	"\x15Z\x09\xaa\xc9\xed\xd4M\xd3(\xfa)[\xf18U" +
	"\x8dI\xe8\xa0\xa6\xf2\xd8.#g\x07jj\xc6^\xdd" +
	"\xee\x1an[RY#\xd1B\xc4\xe5\x17@sm^" +
	"\x87\xfe\xfbz\xed6M\x982\xeew\x99\xa9l\xc7\xc1" +
	"\xff[Vn5\xb29^\xae/,>B\xfe\xe3\x8c" +
	"\xfe\x8b\xc4\xfaz\x81\xb0\x0d|\x84\xfcG\x06\xfd\xd5\xcf" +
	"\xd6qIGeZ\xc8\xab8\xe5]\xa9\x83h\xfd\xf9" +
	"\x1f\xcet\xd8\xbbu\xe23z\xcc\xbaRY\xff\x1b\x00" +
	"\x00\xff\xff9\xb7D\xcd"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_8dcfa60b52844164,
		Nodes: []uint64{
			0x870cd3c7477f97c3,
			0x9c4beb6b068077a3,
			0xae462da6618b7135,
			0xb009687519b3f38f,
			0xb1f8c610d8dbb7dd,
			0xbd2f697b2c16b9a9,
			0xbfb4702210603dcb,
			0xc6f8efbe9e7d5983,
			0xc80a93339b37cb72,
			0xd063789821634bd8,
			0xdb920c957d5a078c,
			0xeb05cc390961a49a,
			0xf139b86f408c2bb0,
			0xf16297be3b2d1ee4,
			0xf1fdeb63c6e87042,
			0xf26fa267f7ea2066,
			0xf3dbf85049fe61f0,
			0xf561891b2176587a,
			0xf9ef9a25541688ef,
		},
		Compressed: true,
	})
}
